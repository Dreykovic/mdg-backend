// types/route.types.ts
export interface RouteConfig {
  method: 'get' | 'post' | 'put' | 'patch' | 'delete';
  path: string;
  handler: string;
  middlewares?: string[];
  validation?: string;
  rateLimit?: number;
}

export interface ControllerConfig {
  controller: string;
  prefix: string;
  middlewares?: string[];
  routes: RouteConfig[];
}

export interface ModuleConfig {
  name: string;
  prefix: string;
  middlewares?: string[];
  controllers: any[];
}

export interface VersionConfig {
  version: string;
  middlewares?: string[];
  modules: ModuleConfig[];
}

export interface AppConfig {
  globalPrefix: string;
  globalMiddlewares?: string[];
  versions: VersionConfig[];
}

// decorators/route.decorators.ts
import 'reflect-metadata';
import { Request, Response, NextFunction } from 'express';

export const CONTROLLER_METADATA = Symbol('controller');
export const ROUTES_METADATA = Symbol('routes');
export const MIDDLEWARES_METADATA = Symbol('middlewares');

export interface RouteMetadata {
  method: 'get' | 'post' | 'put' | 'patch' | 'delete';
  path: string;
  methodName: string;
  middlewares?: string[];
  validation?: string;
  overrideMiddlewares?: boolean; // Si true, ignore les middlewares du controller
}

export interface ControllerMetadata {
  prefix: string;
  middlewares?: string[];
}

// Décorateur Controller - maintenant avec prefix au lieu de basePath
export function Controller(prefix: string, middlewares?: string[]) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    const metadata: ControllerMetadata = { prefix, middlewares };
    Reflect.defineMetadata(CONTROLLER_METADATA, metadata, constructor);
    return constructor;
  };
}

// Décorateur pour middlewares au niveau méthode (additifs par défaut)
export function UseMiddlewares(...middlewares: string[]) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const existingMiddlewares = Reflect.getMetadata(MIDDLEWARES_METADATA, target, propertyKey) || [];
    Reflect.defineMetadata(MIDDLEWARES_METADATA, [...existingMiddlewares, ...middlewares], target, propertyKey);
  };
}

// Décorateur pour remplacer complètement les middlewares du controller
export function OverrideMiddlewares(...middlewares: string[]) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const routes = Reflect.getMetadata(ROUTES_METADATA, target.constructor) || [];
    const routeIndex = routes.findIndex((r: RouteMetadata) => r.methodName === propertyKey);
    
    // Marquer la route pour override des middlewares
    Reflect.defineMetadata(MIDDLEWARES_METADATA, middlewares, target, propertyKey);
    
    if (routeIndex >= 0) {
      routes[routeIndex].overrideMiddlewares = true;
    }
    
    Reflect.defineMetadata(ROUTES_METADATA, routes, target.constructor);
  };
}

// Décorateur pour une route sans aucun middleware (même pas ceux du controller)
export function NoMiddlewares() {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const routes = Reflect.getMetadata(ROUTES_METADATA, target.constructor) || [];
    const routeIndex = routes.findIndex((r: RouteMetadata) => r.methodName === propertyKey);
    
    Reflect.defineMetadata(MIDDLEWARES_METADATA, [], target, propertyKey);
    
    if (routeIndex >= 0) {
      routes[routeIndex].overrideMiddlewares = true;
    }
    
    Reflect.defineMetadata(ROUTES_METADATA, routes, target.constructor);
  };
}

// Factory pour créer les décorateurs HTTP
function createRouteDecorator(method: string) {
  return function (path: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const routes = Reflect.getMetadata(ROUTES_METADATA, target.constructor) || [];
      const middlewares = Reflect.getMetadata(MIDDLEWARES_METADATA, target, propertyKey);
      
      routes.push({
        method: method as any,
        path,
        methodName: propertyKey,
        middlewares
      });
      
      Reflect.defineMetadata(ROUTES_METADATA, routes, target.constructor);
    };
  };
}

// Décorateurs HTTP
export const Get = createRouteDecorator('get');
export const Post = createRouteDecorator('post');
export const Put = createRouteDecorator('put');
export const Patch = createRouteDecorator('patch');
export const Delete = createRouteDecorator('delete');

// controllers/admin/InventoryController.ts
import { Service } from 'typedi';
import { Request, Response } from 'express';
import { Controller, Get, Post, Put, Delete, Patch, UseMiddlewares, OverrideMiddlewares, NoMiddlewares } from '../../decorators/route.decorators';

@Service()
@Controller('/inventory', ['auth', 'rbac:ADMIN']) // Middlewares de controller
export class InventoryController {
  
  @Post('/')
  // Hérite: ['auth', 'rbac:ADMIN'] + validation
  async createInventory(req: Request, res: Response) {
    res.status(201).json({ message: 'Inventory created' });
  }

  @Get('/')
  @UseMiddlewares('cache:300') // Ajoute du cache en plus des middlewares du controller
  // Final: ['auth', 'rbac:ADMIN', 'cache:300']
  async listInventory(req: Request, res: Response) {
    res.json({ inventories: [] });
  }

  @Get('/public')
  @NoMiddlewares() // Aucun middleware, même pas ceux du controller
  // Final: []
  async getPublicInventory(req: Request, res: Response) {
    res.json({ public_inventories: [] });
  }

  @Get('/:id')
  // Hérite: ['auth', 'rbac:ADMIN']
  async getInventory(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ inventory: { id } });
  }

  @Put('/:id')
  @UseMiddlewares('validateOwnership') // Ajoute une vérification de propriété
  // Final: ['auth', 'rbac:ADMIN', 'validateOwnership']
  async updateInventory(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ message: `Inventory ${id} updated` });
  }

  @Delete('/:id')
  @OverrideMiddlewares('auth', 'rbac:SUPER_ADMIN', 'confirmDeletion')
  // Final: ['auth', 'rbac:SUPER_ADMIN', 'confirmDeletion'] (remplace complètement)
  async deleteInventory(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ message: `Inventory ${id} deleted` });
  }

  @Patch('/bulk-update')
  @UseMiddlewares('rateLimit:10', 'validateBulkData')
  // Final: ['auth', 'rbac:ADMIN', 'rateLimit:10', 'validateBulkData']
  async bulkUpdate(req: Request, res: Response) {
    res.json({ message: 'Bulk update completed' });
  }
}

// controllers/admin/ProductController.ts
import { Service } from 'typedi';
import { Request, Response } from 'express';
import { Controller, Get, Post, Put, Delete, Patch } from '../../decorators/route.decorators';

@Service()
@Controller('/products') // Niveau controller
export class AdminProductController {
  
  @Post('/')
  async createProduct(req: Request, res: Response) {
    res.status(201).json({ message: 'Product created' });
  }

  @Get('/')
  async listProducts(req: Request, res: Response) {
    res.json({ products: [] });
  }

  @Get('/:id')
  async getProduct(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ product: { id } });
  }

  @Put('/:id')
  async updateProduct(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ message: `Product ${id} updated` });
  }

  @Patch('/:id/status')
  async updateProductStatus(req: Request, res: Response) {
    const { id } = req.params;
    res.json({ message: `Product ${id} status updated` });
  }
}

// controllers/ecommerce/ProductController.ts
import { Service } from 'typedi';
import { Request, Response } from 'express';
import { Controller, Get, Post, UseMiddlewares, OverrideMiddlewares, NoMiddlewares } from '../../decorators/route.decorators';

@Service()
@Controller('/products') // Pas de middlewares par défaut pour les produits publics
export class EcommerceProductController {
  
  @Get('/')
  @UseMiddlewares('cache:600', 'rateLimit:1000') // Cache + rate limiting pour liste publique
  // Final: ['cache:600', 'rateLimit:1000']
  async listPublicProducts(req: Request, res: Response) {
    res.json({ products: [] });
  }

  @Get('/:slug')
  @UseMiddlewares('cache:300') // Cache pour produit individuel
  // Final: ['cache:300']
  async getProductBySlug(req: Request, res: Response) {
    const { slug } = req.params;
    res.json({ product: { slug } });
  }

  @Get('/admin/all')
  @OverrideMiddlewares('auth', 'rbac:ADMIN') // Route admin dans controller public
  // Final: ['auth', 'rbac:ADMIN'] (remplace les middlewares du controller)
  async getAdminProducts(req: Request, res: Response) {
    res.json({ admin_products: [] });
  }

  @Get('/category/:categoryId')
  @UseMiddlewares('cache:300', 'validateCategory')
  // Final: ['cache:300', 'validateCategory']
  async getProductsByCategory(req: Request, res: Response) {
    const { categoryId } = req.params;
    res.json({ products: [], categoryId });
  }

  @Get('/search')
  @UseMiddlewares('rateLimit:100', 'sanitizeQuery')
  // Final: ['rateLimit:100', 'sanitizeQuery']
  async searchProducts(req: Request, res: Response) {
    const { q } = req.query;
    res.json({ products: [], query: q });
  }

  @Post('/:id/reviews')
  @OverrideMiddlewares('auth', 'rbac:USER', 'validatePurchase') // Seulement auth + validation achat
  // Final: ['auth', 'rbac:USER', 'validatePurchase']
  async createReview(req: Request, res: Response) {
    const { id } = req.params;
    res.status(201).json({ message: `Review created for product ${id}` });
  }

  @Get('/internal/stats')
  @NoMiddlewares() // Route interne sans middlewares (microservices)
  // Final: []
  async getInternalStats(req: Request, res: Response) {
    res.json({ stats: { total: 100 } });
  }
}

// controllers/ecommerce/AuthController.ts
import { Service } from 'typedi';
import { Request, Response } from 'express';
import { Controller, Post, UseMiddlewares } from '../../decorators/route.decorators';

@Service()
@Controller('/auth') // Niveau controller
export class AuthController {
  
  @Post('/login')
  @UseMiddlewares('rateLimit:5')
  async login(req: Request, res: Response) {
    res.json({ token: 'jwt-token', user: {} });
  }

  @Post('/register')
  @UseMiddlewares('rateLimit:3')
  async register(req: Request, res: Response) {
    res.status(201).json({ message: 'User registered', user: {} });
  }

  @Post('/refresh')
  @UseMiddlewares('auth')
  async refreshToken(req: Request, res: Response) {
    res.json({ token: 'new-jwt-token' });
  }

  @Post('/logout')
  @UseMiddlewares('auth')
  async logout(req: Request, res: Response) {
    res.json({ message: 'Logged out successfully' });
  }
}

// controllers/ecommerce/CartController.ts
import { Service } from 'typedi';
import { Request, Response } from 'express';
import { Controller, Get, Post, Put, Delete, UseMiddlewares } from '../../decorators/route.decorators';

@Service()
@Controller('/cart') // Niveau controller
export class CartController {
  
  @Get('/')
  @UseMiddlewares('auth')
  async getCart(req: Request, res: Response) {
    res.json({ cart: { items: [] } });
  }

  @Post('/items')
  @UseMiddlewares('auth')
  async addItem(req: Request, res: Response) {
    res.status(201).json({ message: 'Item added to cart' });
  }

  @Put('/items/:itemId')
  @UseMiddlewares('auth')
  async updateItem(req: Request, res: Response) {
    const { itemId } = req.params;
    res.json({ message: `Cart item ${itemId} updated` });
  }

  @Delete('/items/:itemId')
  @UseMiddlewares('auth')
  async removeItem(req: Request, res: Response) {
    const { itemId } = req.params;
    res.json({ message: `Cart item ${itemId} removed` });
  }

  @Delete('/')
  @UseMiddlewares('auth')
  async clearCart(req: Request, res: Response) {
    res.json({ message: 'Cart cleared' });
  }
}

// core/RouteScanner.ts
import { Router } from 'express';
import Container from 'typedi';
import { CONTROLLER_METADATA, ROUTES_METADATA, RouteMetadata, ControllerMetadata } from '../decorators/route.decorators';
import { MiddlewareRegistry } from './MiddlewareRegistry';
import { ValidationRegistry } from './ValidationRegistry';
import { AppConfig, VersionConfig, ModuleConfig } from '../types/route.types';

export class RouteScanner {
  private middlewareRegistry = new MiddlewareRegistry();
  private validationRegistry = new ValidationRegistry();

  // Méthode principale pour application complète
  public scanApp(config: AppConfig): Router {
    const appRouter = Router();
    
    // Middlewares globaux de l'application
    if (config.globalMiddlewares) {
      config.globalMiddlewares.forEach(middlewareName => {
        const middleware = this.middlewareRegistry.get(middlewareName);
        if (middleware) {
          appRouter.use(middleware);
        }
      });
    }

    // Construire les versions
    const versionsRouter = this.scanVersions(config.versions);
    
    // Appliquer le préfixe global
    appRouter.use(config.globalPrefix, versionsRouter);

    return appRouter;
  }

  private scanVersions(versions: VersionConfig[]): Router {
    const router = Router();

    versions.forEach(version => {
      const versionRouter = this.buildVersionRoutes(version);
      router.use(`/${version.version}`, versionRouter);
    });

    return router;
  }

  private buildVersionRoutes(version: VersionConfig): Router {
    const router = Router();

    // Middlewares de version
    if (version.middlewares) {
      version.middlewares.forEach(middlewareName => {
        const middleware = this.middlewareRegistry.get(middlewareName);
        if (middleware) {
          router.use(middleware);
        }
      });
    }

    // Modules de la version
    version.modules.forEach(module => {
      const moduleRouter = this.buildModuleRoutes(module);
      router.use(`/${module.prefix}`, moduleRouter);
    });

    return router;
  }

  private buildModuleRoutes(module: ModuleConfig): Router {
    const router = Router();

    // Middlewares de module
    if (module.middlewares) {
      module.middlewares.forEach(middlewareName => {
        const middleware = this.middlewareRegistry.get(middlewareName);
        if (middleware) {
          router.use(middleware);
        }
      });
    }

    // Controllers du module
    module.controllers.forEach(ControllerClass => {
      const controllerRouter = this.buildControllerRoutes(ControllerClass);
      if (controllerRouter) {
        const controllerMetadata: ControllerMetadata = Reflect.getMetadata(CONTROLLER_METADATA, ControllerClass);
        router.use(controllerMetadata.prefix, controllerRouter);
      }
    });

    return router;
  }

  private buildControllerRoutes(ControllerClass: any): Router | null {
    const controllerMetadata: ControllerMetadata = Reflect.getMetadata(CONTROLLER_METADATA, ControllerClass);
    const routesMetadata: RouteMetadata[] = Reflect.getMetadata(ROUTES_METADATA, ControllerClass) || [];

    if (!controllerMetadata || routesMetadata.length === 0) {
      return null;
    }

    const router = Router();
    const controller = Container.get(ControllerClass);

    // Routes du controller (les middlewares du controller sont gérés au niveau route)
    routesMetadata.forEach(route => {
      this.addRoute(router, route, controller, controllerMetadata.middlewares);
    });

    return router;
  }

  private addRoute(router: Router, route: RouteMetadata, controller: any, controllerMiddlewares?: string[]): void {
    const middlewares = [];

    // 1. Middlewares du controller (sauf si overrideMiddlewares = true)
    if (!route.overrideMiddlewares && controllerMiddlewares) {
      controllerMiddlewares.forEach(middlewareName => {
        const middleware = this.middlewareRegistry.get(middlewareName);
        if (middleware) middlewares.push(middleware);
      });
    }

    // 2. Validation
    if (route.validation) {
      const validator = this.validationRegistry.get(route.validation);
      if (validator) middlewares.push(validator);
    }

    // 3. Middlewares spécifiques à la route
    if (route.middlewares) {
      route.middlewares.forEach(middlewareName => {
        const middleware = this.middlewareRegistry.get(middlewareName);
        if (middleware) middlewares.push(middleware);
      });
    }

    // Handler de la méthode
    const handler = async (req: any, res: any, next: any) => {
      try {
        await controller[route.methodName](req, res, next);
      } catch (error) {
        next(error);
      }
    };

    router[route.method](route.path, ...middlewares, handler);
  }
}

// core/MiddlewareRegistry.ts
import rateLimit from 'express-rate-limit';
import { verifyJWT } from '../middlewares/auth.middleware';
import { createRbacMiddleware } from '../middlewares/rbac.middleware';

export class MiddlewareRegistry {
  private middlewares = new Map<string, any>();

  constructor() {
    this.registerDefaults();
  }

  private registerDefaults(): void {
    this.middlewares.set('auth', verifyJWT);
    this.middlewares.set('rbac:ADMIN', createRbacMiddleware(['ADMIN']));
    this.middlewares.set('rbac:USER', createRbacMiddleware(['USER']));
    this.middlewares.set('rbac:VENDOR', createRbacMiddleware(['VENDOR']));
    this.middlewares.set('rbac:SUPER_ADMIN', createRbacMiddleware(['SUPER_ADMIN']));
    this.middlewares.set('cors', (req: any, res: any, next: any) => next());
    this.middlewares.set('helmet', (req: any, res: any, next: any) => next());
    
    // Cache middlewares
    this.middlewares.set('cache:300', this.createCacheMiddleware(300));
    this.middlewares.set('cache:600', this.createCacheMiddleware(600));
    
    // Validation middlewares
    this.middlewares.set('validateOwnership', (req: any, res: any, next: any) => {
      console.log('Validating ownership...');
      next();
    });
    this.middlewares.set('validatePurchase', (req: any, res: any, next: any) => {
      console.log('Validating purchase...');
      next();
    });
    this.middlewares.set('validateCategory', (req: any, res: any, next: any) => {
      console.log('Validating category...');
      next();
    });
    this.middlewares.set('sanitizeQuery', (req: any, res: any, next: any) => {
      console.log('Sanitizing query...');
      next();
    });
    this.middlewares.set('confirmDeletion', (req: any, res: any, next: any) => {
      console.log('Confirming deletion...');
      next();
    });
    this.middlewares.set('validateBulkData', (req: any, res: any, next: any) => {
      console.log('Validating bulk data...');
      next();
    });
  }

  public get(name: string): any {
    if (name.includes(':')) {
      const [type, param] = name.split(':');
      
      if (type === 'rbac') {
        return createRbacMiddleware([param]);
      }
      
      if (type === 'rateLimit') {
        return rateLimit({
          windowMs: 15 * 60 * 1000,
          max: parseInt(param),
          message: { error: 'Too many requests' }
        });
      }
      
      if (type === 'cache') {
        return this.createCacheMiddleware(parseInt(param));
      }
    }
    
    return this.middlewares.get(name);
  }

  private createCacheMiddleware(seconds: number) {
    return (req: any, res: any, next: any) => {
      res.set('Cache-Control', `public, max-age=${seconds}`);
      console.log(`Cache set for ${seconds} seconds`);
      next();
    };
  }
}

// core/ValidationRegistry.ts
import { Request, Response, NextFunction } from 'express';

export class ValidationRegistry {
  private validators = new Map<string, any>();

  constructor() {
    // Mock schemas pour l'exemple
    this.validators.set('loginSchema', this.createMockValidator('loginSchema'));
    this.validators.set('registerSchema', this.createMockValidator('registerSchema'));
  }

  private createMockValidator(schemaName: string) {
    return (req: Request, res: Response, next: NextFunction) => {
      // Mock validation - remplacez par votre logique réelle
      console.log(`Validating with ${schemaName}`);
      next();
    };
  }

  public get(name: string): any {
    return this.validators.get(name);
  }
}

// app.ts
import express from 'express';
import { RouteScanner } from './core/RouteScanner';
import { AppConfig } from './types/route.types';

// Import de tous vos controllers
import { InventoryController } from './controllers/admin/InventoryController';
import { AdminProductController } from './controllers/admin/ProductController';
import { EcommerceProductController } from './controllers/ecommerce/ProductController';
import { AuthController } from './controllers/ecommerce/AuthController';
import { CartController } from './controllers/ecommerce/CartController';

const app = express();

// Middlewares globaux
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

const routeScanner = new RouteScanner();

// Configuration complète avec 4 niveaux de préfixage
const appConfig: AppConfig = {
  globalPrefix: '/api',           // Niveau 1: Global
  globalMiddlewares: ['cors', 'helmet'],
  versions: [
    {
      version: 'v1',              // Niveau 2: Version
      middlewares: ['rateLimit:1000'],
      modules: [
        {
          name: 'admin',
          prefix: 'admin',        // Niveau 3: Module
          middlewares: ['auth', 'rbac:ADMIN'],
          controllers: [
            InventoryController,    // Niveau 4: /inventory
            AdminProductController, // Niveau 4: /products
          ]
        },
        {
          name: 'ecommerce',
          prefix: 'shop',         // Niveau 3: Module
          middlewares: [],
          controllers: [
            EcommerceProductController, // Niveau 4: /products
            AuthController,             // Niveau 4: /auth
            CartController,             // Niveau 4: /cart
          ]
        }
      ]
    },
    {
      version: 'v2',              // Niveau 2: Version
      middlewares: ['rateLimit:500'],
      modules: [
        {
          name: 'ecommerce',
          prefix: 'shop',         // Niveau 3: Module
          middlewares: [],
          controllers: [
            // EcommerceProductV2Controller,
          ]
        }
      ]
    }
  ]
};

// Construction des routes avec 4 niveaux de préfixage
const routes = routeScanner.scanApp(appConfig);
app.use(routes);

// Gestion d'erreurs
app.use((err: any, req: any, res: any, next: any) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

export default app;

/*
STRUCTURE URL FINALE :

/api/v1/admin/inventory/           ← Global/Version/Module/Controller
/api/v1/admin/inventory/:id
/api/v1/admin/inventory/bulk-update
/api/v1/admin/products/
/api/v1/admin/products/:id
/api/v1/admin/products/:id/status

/api/v1/shop/products/             ← Même controller name, module différent
/api/v1/shop/products/:slug
/api/v1/shop/products/search
/api/v1/shop/auth/login
/api/v1/shop/auth/register
/api/v1/shop/cart/
/api/v1/shop/cart/items

/api/v2/shop/products/             ← Nouvelle version
*/