// controllers/admin/auth.controller.ts - Version avec Zod
import { Request, Response } from 'express';
import { Service } from 'typedi';
import AdminAuthService from '@/services/auth/auth_service';
import {
  Controller,
  Delete,
  Get,
  Post,
  UseMiddlewares,
} from '@/core/decorators/route.decorators';
import { ControllerErrorHandler } from '@/core/decorators/errorHandler.decorators';
import {
  ValidateBody,
  ValidateRequest,
} from '@/core/decorators/validation.decorators';
import { AuthSchemas, SignInRequest } from '@/validators/auth.validators';
import ApiResponse from '@/core/utils/apiResponse.util';
import logger from '@/core/utils/logger.util';

@Service()
@Controller('/admin')
export class AdminAuthController {
  constructor(private readonly adminAuthService: AdminAuthService) {}

  @Post('/sign-in')
  @ValidateBody(AuthSchemas.signIn)
  @ControllerErrorHandler('Sign In failed.')
  async signIn(req: Request, res: Response): Promise<void> {
    logger.debug('Sign In Request Received');

    // req.body est maintenant typé automatiquement et validé
    const data: SignInRequest = req.body;

    const payload = await this.adminAuthService.signIn(
      data,
      (req as any).clientInfo
    );

    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }

  @Post('/refresh')
  @ValidateBody(AuthSchemas.refreshToken)
  @ControllerErrorHandler('Token refresh failed.')
  async refresh(req: Request, res: Response): Promise<void> {
    logger.debug('Refresh Token Request Received');

    const { token } = req.body; // Typé automatiquement

    const payload = await this.adminAuthService.refreshToken(token);

    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }

  @Delete('/sign-out')
  @ValidateBody(AuthSchemas.logout)
  @UseMiddlewares('auth', 'rbac:ADMIN')
  @ControllerErrorHandler('Logout failed.')
  async logout(req: Request, res: Response): Promise<void> {
    logger.debug('Logout Request Received');

    const { token } = req.body;

    const payload = await this.adminAuthService.logout(token);

    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }

  @Delete('/close-all-sessions')
  @ValidateBody(AuthSchemas.logoutAll)
  @UseMiddlewares('auth', 'rbac:ADMIN')
  @ControllerErrorHandler('Logout from all devices failed.')
  async logoutAll(req: Request, res: Response): Promise<void> {
    logger.debug('Logout All Request Received');

    const { userId } = req.body;

    const payload = await this.adminAuthService.logoutAll(userId);

    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }
}

// Exemple avec validation composée
// controllers/product.controller.ts
@Service()
@Controller('/products')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Post('/')
  @ValidateBody(ProductSchemas.create)
  @UseMiddlewares('auth', 'rbac:ADMIN')
  @ControllerErrorHandler('Product creation failed.')
  async create(req: Request, res: Response): Promise<void> {
    const data: CreateProductRequest = req.body; // Typé automatiquement
    const payload = await this.productService.create(data);
    const response = ApiResponse.http201(payload);
    res.status(response.httpStatusCode).json(response.data);
  }

  @Get('/search')
  @ValidateQuery(ProductSchemas.search)
  @ControllerErrorHandler('Product search failed.')
  async search(req: Request, res: Response): Promise<void> {
    const filters = req.query; // Typé et avec valeurs par défaut
    const payload = await this.productService.search(filters);
    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }

  @Put('/:id')
  @ValidateRequest({
    params: ProductSchemas.idParam,
    body: ProductSchemas.update,
  })
  @UseMiddlewares('auth', 'rbac:ADMIN')
  @ControllerErrorHandler('Product update failed.')
  async update(req: Request, res: Response): Promise<void> {
    const { id } = req.params; // Typé et validé
    const data = req.body; // Typé et validé
    const payload = await this.productService.update(id, data);
    const response = ApiResponse.http200(payload);
    res.status(response.httpStatusCode).json(response.data);
  }
}
